## 10. Односвязный список  

### Определение

**Односвязный список (Singly Linked List)** — это динамическая структура данных,  
состоящая из узлов (**node**), где каждый узел хранит:

1. **значение (data)**
2. **указатель на следующий элемент (next)**
    

> В отличие от массива, элементы списка не расположены подряд в памяти —  
> каждый элемент знает только о следующем.


### Структура узла

```cpp
struct Node {
    int value;    // значение
    Node* next;   // указатель на следующий элемент
    Node(int val) {
        value = val;
        next = nullptr;
    }
};
```


### Основные операции

|Операция|Описание|Асимптотика по времени|
|---|---|---|
|`push_front(x)`|вставка в начало|O(1)|
|`push_back(x)`|вставка в конец|O(n)|
|`pop_front()`|удаление из начала|O(1)|
|`pop_back()`|удаление из конца|O(n)|
|`insert(pos, x)`|вставка по индексу|O(n)|
|`remove(pos)`|удаление по индексу|O(n)|
|`find(x)`|поиск элемента|O(n)|
|`empty()`|проверка на пустоту|O(1)|
|`size()`|длина списка|O(n)|
по памяти `O(1)`
### Реализация

```cpp
#include <iostream>

struct Node {
    int value;    // значение
    Node* next;   // указатель на следующий элемент
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class SinglyLinkedList {
private:
    Node* head;

public:
    SinglyLinkedList() : head(nullptr) {}

    ~SinglyLinkedList() {
        while (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    void push_front(int x) {
        Node* node = new Node(x);
        node->next = head;
        head = node;
    }

    void push_back(int x) {
        Node* node = new Node(x);
        if (!head) {
            head = node;
            return;
        }
        Node* cur = head;
        while (cur->next) cur = cur->next;
        cur->next = node;
    }

    void pop_front() {
        if (!head) return;
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    void pop_back() {
        if (!head) return;
        if (!head->next) {
            delete head;
            head = nullptr;
            return;
        }
        Node* cur = head;
        while (cur->next->next) cur = cur->next;
        delete cur->next;
        cur->next = nullptr;
    }

    void print() {
        Node* cur = head;
        while (cur) {
            std::cout << cur->data << " ";
            cur = cur->next;
        }
        std::cout << "\n";
    }
};
```


### Особенности и отличия от массива

| Характеристика   | Односвязный список                   | Массив                          |
| ---------------- | ------------------------------------ | ------------------------------- |
| Память           | динамическая (каждый элемент в куче) | непрерывный участок             |
| Индексация       | ❌ нет прямого доступа                | ✅ по индексу                    |
| Вставка/удаление | эффективна в начале                  | дорогая (сдвиги)                |
| Перемещение      | только вперёд                        | двустороннее                    |
| Рост структуры   | гибкий (без перераспределений)       | требует realoc при переполнении |
### Использование

- Реализация **стека**, **очереди**, **хэш-таблиц** (цепочки)
- Работа с **неизвестным числом элементов**
- Когда важны **вставки и удаления**, а не быстрый доступ


