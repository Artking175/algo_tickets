## 4. Сортировка слиянием  

**Сортировка слиянием (Merge Sort)** — это алгоритм сортировки, основанный на принципе **разделяй и властвуй**.  
Он рекурсивно делит массив на две части, сортирует каждую из них, а затем **сливает** (merge) эти части в один отсортированный массив.

Сортировка _устойчивая_.
### Идея сортировки

- **Разделение:**  
    Разбиваем массив на две половины.
    
- **Властвование:**  
    Рекурсивно сортируем каждую половину. (Сортировка на подъеме по дереву рекурсии).
    
- **Объединение:**  
    Сливаем две отсортированные половины в один массив.

### Пример

Массив: `[5, 2, 4, 6, 1, 3]`

Разделение:
`[5, 2, 4] | [6, 1, 3]`
`[5, 2] [4] | [6, 1] [3]`
`[5] [2] [4] [6] [1] [3]`

Слияние:
`[2, 5, 4] | [1, 3, 6]`
`[2, 4, 5] | [1, 3, 6]`
`[1, 2, 3, 4, 5, 6]`

### Реализация алгоритма

```cpp
void merge(int arr[], int left, int mid, int right) {
	int size_left = mid - left + 1;    // рамер левого подмассива
	int size_right = right - mid;    // размер правого подмассива
	
	int* arr_left = new int[size_left];    // создаем временные массивы
	int* arr_right = new int [size_right];
	
	for (int i = 0; i < size_left; i++) {    // копируем в них данные
		arr_left[i] = arr[left + i];
	}
	for (int j = 0; j < size_right; j++) {
		arr_right[j] = arr[mid + 1 + j];
	}
	
	int i = 0, j = 0, k = left;    // сливаем 2 массива в 1
	while (i < size_left && j < size_right) {
		if (arr_left[i] <= arr_right[j]) {
			arr[k] = arr_left[i];
			i++;
		} else {
			arr[k] = arr_right[j];
			j++;
		}
		k++;
	}
	
	while (i < size_left) {     // добавляем оставшиеся элементы
		arr[k] = arr_left[i];   // (один массив может закончится раньше...
		i++;                    // ... другого)
		k++;
	}
	
	while (j < size_right) {
		arr[k] = arr_right[j];
		j++;
		k++;
	}
	
	delete[] arr_left;
	delete[] arr_right;
}

void merge_sort(int arr[], int left, int right) {
	if (left >= right) return;   // выход из рекурсии
	int mid = left + (right - left) / 2;
	merge_sort(arr, left, mid);
	merge_sort(arr, mid + 1, right);
	merge(arr, left, mid, right);
}
```

### Временная сложность

Алгоритм всегда делает:

- **деление** массива на 2 части → `log₂(n)` уровней рекурсии,
    
- **слияние** всех элементов на каждом уровне → `O(n)` операций на уровень.
    

Общая сложность:

`T(n) = 2T(n/2) + O(n)`

Используя **Мастер-теорему**:

`T(n) = O(n log n)`

И это — **во всех случаях** (лучший, средний, худший).

### Пространственная сложность

Во время слияния создаётся временный массив (`O(n)` элементов).  
Также есть рекурсивный стек глубиной `O(log n)`.

**Общая память:**

`O(n) + O(log n) ≈ O(n)`
