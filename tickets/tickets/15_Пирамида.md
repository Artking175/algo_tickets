## 15. Пирамида (построение пирамиды, восстановление свойств пирамиды)  

### Определение

**Пирамида (куча, heap)** — это **полное бинарное дерево**, удовлетворяющее **свойству кучи**:

- **Для max-heap**: каждый родитель ≥ своих потомков
    
- **Для min-heap**: каждый родитель ≤ своих потомков
    

Пирамиду часто хранят **в виде массива**, а не в виде указателей на узлы.  
Это позволяет просто вычислять индексы потомков:

```cpp
left(i) = 2 * i + 1;
right(i) = 2 * i + 2;
parent(i) = (i - 1) / 2;
```

### Пример max-heap

```
          10
        /    \
      7        5
     / \      / \
    2   1    3   4

```

Массивное представление:  
`[10, 7, 5, 2, 1, 3, 4]`


### Основные операции

|Операция|Описание|Сложность|
|---|---|---|
|**heapify_down(i)**|восстановление свойства кучи вниз|O(log n)|
|**heapify_up(i)**|восстановление свойства кучи вверх|O(log n)|
|**build_heap()**|построение кучи из массива|O(n)|
|**insert(x)**|добавление нового элемента|O(log n)|
|**extract_max()**|извлечение максимального (min для min-heap)|O(log n)|

### Восстановление свойств пирамиды

#### **1. Просеивание вниз (heapify_down)**

Используется, если нарушено свойство кучи в корне или у родителя.

**Идея:** сравнить элемент с детьми и, если он меньше (для max-heap), поменять местами с наибольшим из них.

```cpp
void heapify_down(int* arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify_down(arr, n, largest);
    }
}
```

### **2. Просеивание вверх (heapify_up)**

Используется после вставки нового элемента в конец.

**Идея:** сравниваем элемент с родителем и поднимаем вверх, пока не восстановится свойство кучи.

```cpp
void heapify_up(int* arr, int i) {
    while (i > 0 && arr[(i - 1) / 2] < arr[i]) {
        std::swap(arr[i], arr[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}
```

