## 2. Оценка сложности алгоритма по памяти  

**Пространственная сложность** — это функция, показывающая, **сколько памяти** использует алгоритм в зависимости от размера входных данных `n`.

> Она показывает, как быстро растёт объём необходимой памяти при увеличении входа.

| Компонент                      | Пример                             | Тип                   |
| ------------------------------ | ---------------------------------- | --------------------- |
| **Входные данные**             | массив `a[n]`, структура графа     | постоянная часть      |
| **Выходные данные**            | результирующий массив, дерево      | постоянная часть      |
| **Вспомогательные переменные** | счётчики, временные буферы         | дополнительная память |
| **Память под рекурсию**        | стек вызовов, локальные переменные | дополнительная память |
| **Динамические структуры**     | векторы, списки, хэш-таблицы       | дополнительная память |

При оценке сложности учитывают:
- переменные (в том числе временные),
- массивы, структуры, объекты, выделенные динамически (`new`, `malloc`),
- стек рекурсии,
- иногда — память под константы (если существенна).
    

Обычно _входные и выходные данные не включаются_ в оценку — интересует именно **дополнительная память**, которую требует алгоритм.

| Тип          | Обозначение            | Что означает                                   |
| ------------ | ---------------------- | ---------------------------------------------- |
| **O(1)**     | Константная память     | Кол-во памяти не зависит от `n`                |
| **O(log n)** | Логарифмическая память | Например, глубина рекурсии при бинарном поиске |
| **O(n)**     | Линейная память        | Доп. массив, список                            |
| **O(n²)**    | Квадратичная память    | Матрицы, таблицы динамики                      |
### Стек вызовов и рекурсия

Каждый рекурсивный вызов создаёт в стеке:
- адрес возврата,
- локальные переменные,
- параметры функции.
    
Если глубина рекурсии `k`, то суммарная память под стек — `O(k)`.

> Поэтому часто рекурсивные алгоритмы оптимизируют в **итеративные**, чтобы уменьшить использование памяти.

Пример для _merge sort_: 
- Память на стек засчет рекурсии: `O(log n)`
- Копии массивов на слиянии: `O(n)`
- Общая память: `O(n)` (так как `n >> log n`)




