## 1. Оценка сложности алгоритма по времени  

**Временная сложность алгоритма** — это функция, которая показывает, как изменяется количество выполняемых операций (или время работы) алгоритма в зависимости от размера входных данных `n`.

> Цель оценки: понять, как быстро растёт время работы при увеличении объёма данных.

| Вид оценки             | Обозначение | Описание                                                                                |
| ---------------------- | ----------- | --------------------------------------------------------------------------------------- |
| **Оценка сверху**      | `O(f(n))`   | Время работы растёт не быстрее, чем `f(n)` (в худшем случае).                           |
| **Оценка снизу**       | `Ω(f(n))`   | Время работы растёт не медленнее, чем `f(n)` (в лучшем случае).                         |
| **Точная асимптотика** | `Θ(f(n))`   | Время работы растёт _ровно_ как `f(n)` — и сверху, и снизу ограничено (средний случай). |

- **Большое O:**  
    `T(n) = O(f(n))`, если ∃ константы `c > 0` и `n₀`, такие что  
    `T(n) ≤ c * f(n)` для всех `n ≥ n₀`.
    
- **Большое Ω:**  
    `T(n) = Ω(f(n))`, если ∃ константы `c > 0` и `n₀`, такие что  
    `T(n) ≥ c * f(n)` для всех `n ≥ n₀`.
    
- **Большое Θ:**  
    `T(n) = Θ(f(n))`, если `T(n)` одновременно `O(f(n))` и `Ω(f(n))`.

| Сценарий           | Обозначение | Пример                                           |
| ------------------ | ----------- | ------------------------------------------------ |
| **Лучший случай**  | `Ω(f(n))`   | Быстрый выход из поиска (первый элемент найден). |
| **Худший случай**  | `O(f(n))`   | Элемент отсутствует, нужно проверить всё.        |
| **Средний случай** | `Θ(f(n))`   | Ожидаемое время при случайных данных.            |
### Практические приёмы

1. **Игнорировать константы и младшие члены:**  
    `3n² + 10n + 5 → O(n²)`
    
2. **Суммировать вложенные циклы:**  
    Если циклы вложены, умножай итерации (`n * n` → `O(n²)`).
    
3. **Если циклы последовательны**, то складывать:  
    `O(n) + O(n²) = O(n²)` (берётся старший порядок).
    
4. **Следить за рекурсией:**  
    используем **рекуррентные соотношения** для оценки 
    (`T(n) = 2T(n/2) + O(n)` → `O(n log n)`).

