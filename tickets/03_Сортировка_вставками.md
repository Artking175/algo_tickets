## 3. Сортировка вставками  

### Идея сортировки

1. Первый элемент массива считаем уже отсортированным.
2. Берём следующий элемент и **вставляем** его в правильное место **среди уже отсортированных** элементов слева.
3. Повторяем для всех элементов массива.

Сортировка _устойчивая_.

### Пример

Пусть массив:  
`[5, 2, 4, 6, 1, 3]`

| Шаг | Текущий элемент | После вставки                       |
| --- | --------------- | ----------------------------------- |
| 1   | 2               | `[2, 5, 4, 6, 1, 3]`                |
| 2   | 4               | `[2, 4, 5, 6, 1, 3]`                |
| 3   | 6               | `[2, 4, 5, 6, 1, 3]` (уже на месте) |
| 4   | 1               | `[1, 2, 4, 5, 6, 3]`                |
| 5   | 3               | `[1, 2, 3, 4, 5, 6]`                |

### Реализация алгоритма

```cpp
void InsertionSort(int* arr, int size) {
	for (int i = 1; i < size; i++) {
		int current = arr[i];
		int j = i - 1;
		for (; j >= 0 %% arr[j] > current; j--) {
			arr[j + 1] = arr[j];
		}
		arr[j + 1] = current;
	}
}
```

### Асимптотическая сложность

| Случай                            | Количество сравнений и сдвигов                                         | Время     |
| --------------------------------- | ---------------------------------------------------------------------- | --------- |
| **Лучший (уже отсортирован)**     | каждый `a[i]` ≥ предыдущего → внутренний цикл не выполняется           | **O(n)**  |
| **Худший (обратно отсортирован)** | каждый элемент нужно вставлять в начало → сдвигов: `1 + 2 + … + (n−1)` | **O(n²)** |
| **Средний**                       | примерно половина элементов сдвигается                                 | **O(n²)** |
### Пространственная сложность

- Использует только несколько дополнительных переменных (`current`, `i`, `j`)  
    **O(1)** 
