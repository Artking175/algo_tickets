## 20. Динамическое программирование:  

### Общая идея динамического программирования

**Динамическое программирование (DP)** — это метод решения задач,  
в которых решение можно представить как комбинацию **решений подзадач**,  
и каждая подзадача **используется многократно**.

Идея:

- Разбить задачу на подзадачи.
    
- Решать их один раз.
    
- Сохранять результаты (мемоизация / табуляция).

**Примером является числа Фибоначчи**:
```cpp
int Fibonacci(int n){
    if (n <= 1){
        return 1;
    }
    if (fib[n] == -1){
        fib[n] = Fibbonacci(n - 1) + Fibbonacci(n - 2);
    } // проверяем, что не посчитали
    return fib[n];
}
```
>Этот пример показывает:
Мы можем считать маленькие части и приходить через них к ответу: f(n) = f(n -1 ) + f(n - 2).
Также мы можем запоминать ответы, чтобы находить их быстрее в дальнейшем.

DP обычно применимо, если выполняются два свойства:

1. **Оптимальная подструктура** — оптимальное решение составляется из оптимальных подрешений.
    
2. **Пересекающиеся подзадачи** — одни и те же подпроблемы встречаются многократно.
---
### Кузнечик

#### Условие

Кузнечик сидит на клетке `1` и может прыгать вперёд на 1 или 2 клетки.  
Нужно посчитать, **сколькими способами** он может добраться до клетки `n`.

### Рекуррентное соотношение

```
dp[i] = dp[i−1] + dp[i−2]
```

где

- `dp[i]` — количество способов добраться до клетки `i`.

#### Реализация 

```cpp
int grasshopper(int n) {
    int dp[n + 1];
    dp[1] = 1; // задаем базу
    dp[2] = 2; // задаем базу 
    for (int i = 3; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[n];
}
```

модификация (теперь без использования массива)
```cpp
int grasshopper(int n) {
    if (n == 1) return 1;
    if (n == 2) return 1;

    int prev2 = 1; // dp[i-2]
    int prev1 = 2; // dp[i-1]
    int curr;

    for (int i = 3; i <= n; i++) {
        curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return curr;
}
```

#### Асимптотика

| Время  | Память                              |
| ------ | ----------------------------------- |
| `O(n)` | `O(n)` (или `O(1)` при оптимизации) |
---
### Рюкзак

#### Постановка задачи

Есть `n` предметов, каждый с:

- весом `w[i]`,
    
- ценностью (стоимостью) `c[i]`.
    

Дан рюкзак вместимости `W`.  
Нужно выбрать набор предметов так, чтобы:

- **суммарный вес ≤ W**,
    
- **суммарная ценность** — **максимальна**.  
    При этом **предмет можно взять только один раз**
    >Усложненная задача - предмет можно брать несколько раз 

#### Рекуррентная формула

Пусть `dp[i][j]` — **максимальная ценность**,  
которую можно получить, рассматривая **первые `i` предметов** и рюкзак вместимости `j`.

```
dp[i][j] = dp[i − 1][j] // если w[i] > j (не помещается)
dp[i][j] = max(dp[i − 1][j], dp[i − 1][j − w[i]] + c[i]) // если w[i] <= i
```

#### Пример

Пусть:

| i   | Вес | Цена |
| --- | --- | ---- |
| 1   | 2   | 3    |
| 2   | 3   | 4    |
| 3   | 4   | 5    |

`W = 5`

#### Пошаговое построение `dp` :

| i / W | 0   | 1   | 2   | 3   | 4   | 5   |
| ----- | --- | --- | --- | --- | --- | --- |
| 0     | 0   | 0   | 0   | 0   | 0   | 0   |
| 1     | 0   | 0   | 3   | 3   | 3   | 3   |
| 2     | 0   | 0   | 3   | 4   | 4   | 7   |
| 3     | 0   | 0   | 3   | 4   | 5   | 7   |

##### Как заполняем таблицу

Мы будем идти **построчно (по предметам)** и **покомпонентно (по весу)**.  
Формула:

```cpp
if (w[i] <= j)
    dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + c[i])
else
    dp[i][j] = dp[i-1][j]; // берем просто клетку на строчку выше 
```

Расшифровка:

- `dp[i-1][j]` — не берём предмет `i` (ценность такая же, как без него);
    
- `dp[i-1][j - w[i]] + c[i]` — берём предмет `i`:
    
    - убираем из рюкзака место под его вес `w[i]`;
        
    - добавляем его ценность `c[i]`.
        

Берём максимум из этих двух вариантов.

#### Реализация

dp как двумерный массив:
```cpp
int knapsack(int n, int W, int* w, int* c) {
    int dp[n + 1][W + 1] = {0};

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            if (w[i - 1] <= j)
                dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + c[i - 1]);
            else
                dp[i][j] = dp[i - 1][j];
        }
    }
    return dp[n][W];
}
```

dp как одномерный массив:
```cpp
int knapsack(int n, int W, int* w, int* c) {
    int dp[W + 1] = {0};
    for (int i = 0; i < n; i++) {
        for (int j = W; j >= w[i]; j--) {
            dp[j] = std::max(dp[j], dp[j - w[i]] + c[i]);
        }
    }
    return dp[W];
}
```

#### Почему работает 1D реализация

В классическом (2D) варианте dp[i][j] хранит максимум для первых i предметов и вместимости j.
Когда мы переходим к предмету i+1, мы используем только предыдущую строку dp[i−1][...].

Чтобы не хранить всю таблицу, можно «свернуть» её в один массив dp[j],
где dp[j] всегда будет обозначать текущее максимальное значение для вместимости j.

Важное условие — **порядок обхода**:

Чтобы не «перезаписать» значения, которые нам ещё понадобятся,
внутренний цикл по j нужно выполнять в обратном порядке — от W к w[i].

#### Асимптотика 

|Параметр|Асимптотика|
|---|---|
|Время|`O(n * W)`|
|Память (2D)`|`O(n * W)`|
|Память (1D)`|`O(W)`|


#### Восстановление ответа

После того как таблица `dp[i][j]` заполнена, значение `dp[n][W]` показывает **максимальную ценность**,  
но **какие предметы взяты**, нужно восстановить отдельно.

##### Алгоритм восстановления

1. Начинаем с нижнего правого угла: `i = n`, `j = W`.
    
2. Пока `i > 0` и `j > 0`:
    
    - Если `dp[i][j] == dp[i - 1][j]`,  
        → предмет `i` **не был взят**, идём к `i = i - 1`.
        
    - Иначе  
        → предмет `i` **взят**,  
        запоминаем его и переходим к:
        
        `j = j - w[i - 1]`
        `i = i - 1`
        
3. Получаем список всех взятых предметов (его можно развернуть для порядка).
    

##### Пример восстановления

| i / W | 0   | 1   | 2   | 3   | 4   | 5   |
| ----- | --- | --- | --- | --- | --- | --- |
| 0     | 0   | 0   | 0   | 0   | 0   | 0   |
| 1     | 0   | 0   | 3   | 3   | 3   | 3   |
| 2     | 0   | 0   | 3   | 4   | 4   | 7   |
| 3     | 0   | 0   | 3   | 4   | 5   | 7   |

`dp[3][5] = 7`

- `dp[3][5] == dp[2][5]` → предмет 3 не взят
    
- `dp[2][5] != dp[1][5]` → предмет 2 взят → `j = 5 - 3 = 2`
    
- `dp[1][2] != dp[0][2]` → предмет 1 взят  
    → ответ: {1, 2}, суммарная ценность = 7.
    

##### Код восстановления

```cpp
void restoreItems(int n, int W, int* w, int* c, int dp[][101]) {
    int j = W;
    std::vector<int> items;

    for (int i = n; i > 0; i--) {
        if (dp[i][j] != dp[i - 1][j]) {
            items.push_back(i);
            j -= w[i - 1];
        }
    }

    std::reverse(items.begin(), items.end());
    std::cout << "Взятые предметы: ";
    for (int x : items) std::cout << x << " ";
}

```


##### Асимптотика

| Параметр    | Асимптотика |
| ----------- | ----------- |
| Время       | `O(n * W)`  |
| Память (2D) | `O(n * W)`  |
| Память (1D) | `O(W)`      |

---
### Наибольшая возрастающая подпоследовательность (Longest Increasing Subsequence, LIS)

#### Постановка задачи

Дана последовательность чисел: `a₁, a₂, ..., aₙ`

Нужно найти **длину самой длинной строго возрастающей подпоследовательности**,  
т.е. выбрать элементы с возрастающими индексами и значениями:

`a[i₁] < a[i₂] < ... < a[iₖ]`  так, чтобы `k` — было **максимально возможным**.

#### Пример

Пусть дана последовательность:

`a = [5, 4, 1, 2, 5, 3, 6, 7]`

Одна из самых длинных возрастающих подпоследовательностей:

`[1, 2, 3, 6, 7]`

#### Идея динамического программирования

Для каждого элемента `a[i]` будем хранить:

> `dp[i]` — длина наибольшей возрастающей подпоследовательности,  
> **заканчивающейся именно на элементе `a[i]`**.

#### Формула перехода:

Для всех `j < i`, если `a[j] < a[i]`, то  
элемент `a[i]` можно поставить **после** `a[j]` в возрастающую подпоследовательность.

`dp[i] = max(dp[j]) + 1   для всех j < i, где a[j] < a[i]`

#### Реализация

```cpp
vector<int> findLIS(vector<int> a){
    int n = a.size(); // исходные размеры 
    int prev[n];
    int d[n];

    for (int i = 0; i < n; ++i){
        d[i] = 1;
        prev[i] = -1;
        for (int j = 0; j < i; ++j){
            if (a[j] < a[i] && d[j] + 1 > d[i]){
                d[i] = d[j] + 1;
                prev[i] = j;
            }
        }
    }
    int pos = 0; // индекс последнего элемента НВП
    int length = d[0]; // длина НВП
    for (int i = 0; i < n -1; ++i){
        if (d[i] > length){
            pos = i;
            length = d[i];
        }
    }

    // восстановление ответа
    vector<int> ans;
    while (pos != -1){
        ans.push_back(a[pos]);
        pos = prev[pos];
    }
    std::reverse(ans.begin(), ans.end());

    return ans;
}
```
### Из примера выше, массив динамики будет таким:

|5|4|1|2|5|3|6|7|
|---|---|---|---|---|---|---|---|
|1|1|1|2|3|3|4|5

**Как восстановить ответ?**
Необходимо хранить массив prev, где каждый элемент - индекс, по которому мы пришли в текущий индекс.
|5|4|1|2|5|3|6|7|
|---|---|---|---|---|---|---|---|
|1|1|1|2|3|3|4|5
|-1|-1|-1|2|3|3|5|6|

Ходим по массиву prev и выводим элементы из финальной последовательности.


#### Асимптотика

- Временная — `O(n²)`
- Память — `O(n)`

>Можно улучшить до `O(n log n)`, изменив динамику. И использовать бинарный поиск.

|5|4|1|2|5|3|6|7|
|---|---|---|---|---|---|---|---|
|x|1|2|3|6|7|$\infty$|$\infty$|
|-1|-1|-1|2|3|3|5|6|

#### Реализация
```cpp
vector<int> findLIS(vector<int> a){
    int n = a.size(); // исходные размеры 
    int prev[n];
    int d[n];
    int pos[n];
    int length = 0;

    for (int i = 0; i < n; ++i){
        int j = std::lower_bound(d, d + length, a[i]) - d; // бинпосик
        d[j] = a[i];
        pos[j] = i;

        if (j > 0){
            prev[i] = pos[j - 1];
        } else {
            prev[i] = -1;
        }
        if (j == length){
            length++;
        }
    }

    // восстановление ответа
    vector<int> ans;
    int p = pos[length - 1];
    while (p != -1){
        ans.push_back(a[p]);
        p = prev[p];
    }
    std::reverse(ans.begin(), ans.end());

    return ans;
}
```

---

### Редакционное расстояние
`ПОЛЕНО->ПЛЕНО->ПЛЕМО->ПЛЕМЯ`
**Задача**: имеется два слова. Нужно из первого получить второе, используя три операции: удалять букву, вставлять букву, изменять букву.
Будем пользоваться принципом оптимальности на префиксе: сколько надо сделать изменений, чтобы получить из префикса первого слова префикс второго?
>`d[i][j]` - стоимость получения из префикса длины i первого слова префикс длины j второго слова.

**Сделаем несколько правил**:
- Первое правило (insert): `d[i][j] = d[i][j - 1] + insertCost`.
- Второе правило (delete): `d[i][j] = d[i - 1][j] + deleteCost`.
- Третье правило (change): `d[i][j] = d[i - 1][j - 1] + changeCost`
Из этих трех возможностей хотим ту, что имеет минимальную стоимость.

| |0|1(п)|2(л)|3(е)|4(м)|5(я)|
|---|---|---|---|---|---|---|
|0|0|1|2|3|4|5|
|1(п)|1|0|1|2|3|4|
|2(о)|2|1|1|2|3|4|
|3(л)|3|2|1|2|3|4|
|4(е)|4|3|2|1|2|3|
|5(н)|5|4|3|2|2|3|
|6(о)|6|5|4|3|3|3|

>После заполнения таблицы, идем по минимальным значениям: вверх - `delete`, влево - `insert`, диагональ - `replace/equal`.

Для получения ответа идем из правой нижней клетки в левую верхнюю.
> Время работы - `O(s1 * s2)` размеры слов.

**Реализация**
```cpp
int levensteunInstruction(string& s1, string& s2, int insertCost, int deleteCost, int replaceCost){
    int m = s1.size();
    int n = s2.size();

    int D[m + 1][n + 1]; 
    D[0][0] = 0; // базовый случай

    for (int j = 1; j <= n; ++j){ // инициализация первой строки
        D[0][j] = D[0][j - 1] + insertCost;
    }
    for (int i = 1; i <= m; ++i){ // инициализация первого столбца
        D[i][0] = D[i - 1][0] + deleteCost;
    }

    for (int i = 1; i <= n; ++i){ // заполнение остальной части матрицы
        for (int j = 1; j <= m; ++j){
            if (s1[i - 1] == s2[j - 1]){
                D[i][j] = D[i - 1][j - 1]; // если совпадение
            } else {
                D[i][j] = min(D[i - 1][j] + deleteCost, D[i][j - 1] + insertCost, D[i - 1][j - 1] + replaceCost); // выбираем минимальну операцию по стоимости
            }
        }
    }
    return D[n][m];
}
```

--- 

### Расстановка знаков в выражении

**Задача**: Даны числа. Хотим расставить +/*/скобки так, чтобы выражение имело максимальное значение.
Будем прользоваться принципом оптимальности на подотрезке. Пусть `d[i][j]` - максимальное значение, которое мы можем получить на отрезке от `i` до `j`.
**Пример**:
1324->`3+8` или `3*8`->`3*8` оказывается лучшим вариантом
| |0(1)|1(3)|2(2)|3(4)|
|---|---|---|---|---|
|0(1)|1|4|8|32|
|1(3)|0|3|6|24|
|2(2)|0|0|2|8|
|3(4)|0|0|0|4|

Сначала таблица заполняется нулями, так как не бывает отрезков, где левая граница правее правой. На отрезках длиной `1` имеем только один операнд->сразу записываем. Для `6` смотрим варианты для `3` и `2`. Аналогично для `8`. Дальше берем максимум (левой и нижней клетки через одну) или (нижней и левой через одну).
>Для восстановления необходимо хранить, какую пару мы выбрали.
**Время работы - O($n^3$) :(**

**Реализация**
```cpp
int maxValueExpression(int a[], int n){
    int d[n + 1][n + 1]; // максимальное значение на подотрезке

    for (int i = 1; i <= n; ++i){ // базовый случай
        d[i][i] = a[i];
    }

    for (int len = 2; len <= n; ++len){ // перебираем длину отрезка
        for (int i = 1; i + len - 1 <= n; ++i){ // начало отрезка
            int j = i + len - 1; // конец отрезка
            d[i][j] = 0;

            for (int k = i; k < j; ++k){ // перебор места разбиаения выражения
                int add = d[i][k] + d[k + 1][j];
                int mul = d[i][k] * d[k + 1][j];

                d[i][j] = std::max(d[i][j], std::max(add, mul));
            }
        }
    }
    return d[1][n];
}
```

---

### Замощение доминошек

**Задача:** Дана таблица m*n. Необходимо вычислить количество способов заполнить ее доминошками.
Профиль - для `i`-го столбца набор из ноликов и единичек. `0` -домино не влезает. `1` - домино влезает за границы.
Динамика по (`i`, `p`) - по номеру столбца и профилю.
>Профилей может быть $2^m$

Из профиля `i` в профиль `j` можно перейти если выполняются условия:
 - Можно положить горизонтальные домино. То есть там где в `j` профиле стоит `1`, в `i` профиле должен стоять `0`.
 - Можно доложить оставшиеся клетки вертикальное домино. То есть оставшиеся `0` в `i` профиле должны образовывать четные подстроки.

Будем для всех пар профилей хранить, можно ли между ними пройти.
>`A[i][p]` - количество способов замостить первые `i` столбцов так, чтобы они заканчивались на `p`-ый профиль.
`D[i][j]` - возможен ли переход из `i` профиля в `j`-ый.

`A[i][p]` = $\sum$(по всем j) `A[i-1][j] * d[j][p]`.
**Ответом будет** $\sum$ `A[m][i]`, где `i` - профиль, который может быть последним (т.е. все группы из `0` имеют четные размеры).
>Сложность: d - $2^{2m}$ и подсчет a - $2^{2m}n$ в итоге O($2^{2m}n$).

**Реализация**
```cpp
const int MAXN = 100;
const int MAXM = 1000;

int n, m;
int d[1 << MAXN][1 << MAXN];
long long a[MAXN + 1][1 << MAXN];

bool compatible(int i, int j){
    int mask = i | j; // проверка, можно ли замостить столбец, если слева i, справа j
    for (int k = 0; k < n; ++k){
        if (!(mask & (1 << k))){
            if (k + 1 < n && !(mask & (1 << (k + 1)))){ // пытаемся поставить вертикально
                k++; // закрытие двух клеток
            } else {
                return false;
            }
        }
    }
    return true;
}
long long domino(int n1, int m1){
    n = n1;
    m = m1;
    int p = 1 << n;

    for (int i = 0; i < p; ++i){ // таблица переходов
        for (int j = 0; j < p; ++j){
            if (compatible(i, j)){
                d[i][j] = 1;
            } else {
                d[i][j] = 0;
            }
        }
    }
    memset(a, 0, sizeof(a)); // инициализация dp от мусора
    a[0][0] = 1;

    for (int k = 1; k <= m; ++k){ // наша динамика
        for (int i = 0; i < p; ++i){
            for (int j = 0; j < p; ++j){
                if (d[i][j] == 1){
                    a[k][i] += a[k-1][j]
                }
            }
        }
    }
    return a[m][0]; // закончить можно только пустым профилем
}
```

---

### Примеры вопросов:
- Что такое дп? Какими основными принципами надо пользоваться?
- Как можно сделать динамику?
- Что такое подзадачи? 
- Что такое мемоизация?
- На примере Фибоначчи показать главные правила dp.
- Что такое состояние и переход состояния?
- Какие есть ограничения у Dp?
- Рассказать про рюкзак. Его ассимптотики. Как восстанавливать ответ?
- Как можно оптимизировать рюкзак?
- Задача, если можно брать предмет несколько раз.
- Что такое НВП? Его состояния? Временная сложность.
- Как оптимизировать НВП? Для чего нам нужен бинарный поиск?
- Как восстановить последовательность?
- Что такое редакционное расстояние? Какие операции существуют?
- Как устроен переход: минимизация трёх операций?
- Как восстанавливается ответ?
- Рассказать про замощение доминошек. Что такое профили?
- Временная сложность доминошек.
- Главная идея кузнечика. Переходы.
- Ассимптотика кузнечика.
- Как восстанавливается путь?
- Задача на расстановку знаков. Ассимптотика. Переходы.
- Отличие от обычной суммы подмассивов.
- Последовательность T задана следующей формулой `T[i] = T[i - 1] + T[i - 2] + 2 * T[i - 3]. T[1] = 1, T[2] = 7`. Найдите ее 5-ый член (индексация с нуля).